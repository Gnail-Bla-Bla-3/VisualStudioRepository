  Compiling CUDA source file main.cu...
  
  C:\Users\Liang Nie\Documents\GitHub\VisualStudioRepository\Project1\Project1>"C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\bin\nvcc.exe" -gencode=arch=compute_86,code=\"sm_86,compute_86\" --use-local-env -ccbin "C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.36.32532\bin\HostX86\x86" -x cu   -I"C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include" -I"C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include" -I"C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include"  -G   --keep-dir Debug  -maxrregcount=0   --machine 64 --compile -cudart static  -g  -DWIN32 -D_DEBUG -D_CONSOLE -D_UNICODE -DUNICODE -Xcompiler "/EHsc /W3 /nologo /Od /FS /Zi /RTC1 /MDd " -Xcompiler "/FdDebug\vc143.pdb" -o "C:\Users\Liang Nie\Documents\GitHub\VisualStudioRepository\Project1\Project1\Debug\main.cu.obj" "C:\Users\Liang Nie\Documents\GitHub\VisualStudioRepository\Project1\Project1\main.cu" 
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(1678): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.nc.b32 %0, [%1];"  : "=r"(*(reinterpret_cast<unsigned int *>(&(ret)))) : "r"(ptr));
                                                                                                 ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(1684): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.nc.b16 %0, [%1];"  : "=h"(*(reinterpret_cast<unsigned short *>(&(ret)))) : "r"(ptr));
                                                                                                   ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(1690): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.cg.b32 %0, [%1];"  : "=r"(*(reinterpret_cast<unsigned int *>(&(ret)))) : "r"(ptr));
                                                                                                 ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(1696): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.cg.b16 %0, [%1];"  : "=h"(*(reinterpret_cast<unsigned short *>(&(ret)))) : "r"(ptr));
                                                                                                   ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(1702): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.ca.b32 %0, [%1];"  : "=r"(*(reinterpret_cast<unsigned int *>(&(ret)))) : "r"(ptr));
                                                                                                 ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(1708): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.ca.b16 %0, [%1];"  : "=h"(*(reinterpret_cast<unsigned short *>(&(ret)))) : "r"(ptr));
                                                                                                   ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(1714): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.cs.b32 %0, [%1];"  : "=r"(*(reinterpret_cast<unsigned int *>(&(ret)))) : "r"(ptr));
                                                                                                 ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(1720): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.cs.b16 %0, [%1];"  : "=h"(*(reinterpret_cast<unsigned short *>(&(ret)))) : "r"(ptr));
                                                                                                   ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(1726): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.lu.b32 %0, [%1];"  : "=r"(*(reinterpret_cast<unsigned int *>(&(ret)))) : "r"(ptr) : "memory");
                                                                                                 ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(1732): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.lu.b16 %0, [%1];"  : "=h"(*(reinterpret_cast<unsigned short *>(&(ret)))) : "r"(ptr) : "memory");
                                                                                                   ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(1738): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.cv.b32 %0, [%1];"  : "=r"(*(reinterpret_cast<unsigned int *>(&(ret)))) : "r"(ptr) : "memory");
                                                                                                 ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(1744): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.cv.b16 %0, [%1];"  : "=h"(*(reinterpret_cast<unsigned short *>(&(ret)))) : "r"(ptr) : "memory");
                                                                                                   ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(1749): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("st.global.wb.b32 [%0], %1;"  :: "r"(ptr), "r"(*(reinterpret_cast<const unsigned int *>(&(value)))) : "memory");
                                              ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(1753): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("st.global.wb.b16 [%0], %1;"  :: "r"(ptr),  "h"(*(reinterpret_cast<const unsigned short *>(&(value)))) : "memory");
                                              ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(1757): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("st.global.cg.b32 [%0], %1;"  :: "r"(ptr), "r"(*(reinterpret_cast<const unsigned int *>(&(value)))) : "memory");
                                              ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(1761): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("st.global.cg.b16 [%0], %1;"  :: "r"(ptr),  "h"(*(reinterpret_cast<const unsigned short *>(&(value)))) : "memory");
                                              ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(1765): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("st.global.cs.b32 [%0], %1;"  :: "r"(ptr), "r"(*(reinterpret_cast<const unsigned int *>(&(value)))) : "memory");
                                              ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(1769): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("st.global.cs.b16 [%0], %1;"  :: "r"(ptr),  "h"(*(reinterpret_cast<const unsigned short *>(&(value)))) : "memory");
                                              ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(1773): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("st.global.wt.b32 [%0], %1;"  :: "r"(ptr), "r"(*(reinterpret_cast<const unsigned int *>(&(value)))) : "memory");
                                              ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(1777): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("st.global.wt.b16 [%0], %1;"  :: "r"(ptr),  "h"(*(reinterpret_cast<const unsigned short *>(&(value)))) : "memory");
                                              ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(2681): error : asm operand type size(8) does not match type/size implied by constraint 'r'
                      : "=r"(*(reinterpret_cast<unsigned int *>(&(r)))) : "r"(address), "r"(*(reinterpret_cast<const unsigned int *>(&(val))))
                                                                          ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_fp16.hpp(2694): error : asm operand type size(8) does not match type/size implied by constraint 'r'
                      : "r"(address), "h"(*(reinterpret_cast<const unsigned short *>(&(val))))
                        ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_bf16.hpp(1653): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.nc.b32 %0, [%1];"  : "=r"(*(reinterpret_cast<unsigned int *>(&(ret)))) : "r"(ptr));
                                                                                                 ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_bf16.hpp(1659): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.nc.b16 %0, [%1];"  : "=h"(*(reinterpret_cast<unsigned short *>(&(ret)))) : "r"(ptr));
                                                                                                   ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_bf16.hpp(1665): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.cg.b32 %0, [%1];"  : "=r"(*(reinterpret_cast<unsigned int *>(&(ret)))) : "r"(ptr));
                                                                                                 ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_bf16.hpp(1671): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.cg.b16 %0, [%1];"  : "=h"(*(reinterpret_cast<unsigned short *>(&(ret)))) : "r"(ptr));
                                                                                                   ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_bf16.hpp(1677): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.ca.b32 %0, [%1];"  : "=r"(*(reinterpret_cast<unsigned int *>(&(ret)))) : "r"(ptr));
                                                                                                 ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_bf16.hpp(1683): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.ca.b16 %0, [%1];"  : "=h"(*(reinterpret_cast<unsigned short *>(&(ret)))) : "r"(ptr));
                                                                                                   ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_bf16.hpp(1689): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.cs.b32 %0, [%1];"  : "=r"(*(reinterpret_cast<unsigned int *>(&(ret)))) : "r"(ptr));
                                                                                                 ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_bf16.hpp(1695): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.cs.b16 %0, [%1];"  : "=h"(*(reinterpret_cast<unsigned short *>(&(ret)))) : "r"(ptr));
                                                                                                   ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_bf16.hpp(1701): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.lu.b32 %0, [%1];"  : "=r"(*(reinterpret_cast<unsigned int *>(&(ret)))) : "r"(ptr) : "memory");
                                                                                                 ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_bf16.hpp(1707): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.lu.b16 %0, [%1];"  : "=h"(*(reinterpret_cast<unsigned short *>(&(ret)))) : "r"(ptr) : "memory");
                                                                                                   ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_bf16.hpp(1713): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.cv.b32 %0, [%1];"  : "=r"(*(reinterpret_cast<unsigned int *>(&(ret)))) : "r"(ptr) : "memory");
                                                                                                 ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_bf16.hpp(1719): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("ld.global.cv.b16 %0, [%1];"  : "=h"(*(reinterpret_cast<unsigned short *>(&(ret)))) : "r"(ptr) : "memory");
                                                                                                   ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_bf16.hpp(1725): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("st.global.wb.b32 [%0], %1;"  :: "r"(ptr), "r"(*(reinterpret_cast<const unsigned int *>(&(value)))) : "memory");
                                              ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_bf16.hpp(1729): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("st.global.wb.b16 [%0], %1;"  :: "r"(ptr),  "h"(*(reinterpret_cast<const unsigned short *>(&(value)))) : "memory");
                                              ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_bf16.hpp(1733): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("st.global.cg.b32 [%0], %1;"  :: "r"(ptr), "r"(*(reinterpret_cast<const unsigned int *>(&(value)))) : "memory");
                                              ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_bf16.hpp(1737): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("st.global.cg.b16 [%0], %1;"  :: "r"(ptr),  "h"(*(reinterpret_cast<const unsigned short *>(&(value)))) : "memory");
                                              ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_bf16.hpp(1741): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("st.global.cs.b32 [%0], %1;"  :: "r"(ptr), "r"(*(reinterpret_cast<const unsigned int *>(&(value)))) : "memory");
                                              ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_bf16.hpp(1745): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("st.global.cs.b16 [%0], %1;"  :: "r"(ptr),  "h"(*(reinterpret_cast<const unsigned short *>(&(value)))) : "memory");
                                              ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_bf16.hpp(1749): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("st.global.wt.b32 [%0], %1;"  :: "r"(ptr), "r"(*(reinterpret_cast<const unsigned int *>(&(value)))) : "memory");
                                              ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cuda_bf16.hpp(1753): error : asm operand type size(8) does not match type/size implied by constraint 'r'
        asm ("st.global.wt.b16 [%0], %1;"  :: "r"(ptr),  "h"(*(reinterpret_cast<const unsigned short *>(&(value)))) : "memory");
                                              ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub/util_device.cuh(100): warning #767-D: conversion from pointer to smaller integer
        d_temp_storage = (void *) ((size_t(d_temp_storage) + ALIGN_BYTES - 1) & ALIGN_MASK);
                                    ^
  
  Remark: The warnings can be suppressed with "-diag-suppress <warning-number>"
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(271): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CA, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""ca"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CA, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""ca"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CA, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""ca"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CA, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""ca"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CA, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""ca"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CA, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""ca"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CA, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""ca"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CA, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""ca"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                           ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(271): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CA, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""ca"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CA, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""ca"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CA, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""ca"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CA, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""ca"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CA, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""ca"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CA, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""ca"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CA, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""ca"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CA, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""ca"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(271): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CA, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""ca"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CA, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""ca"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CA, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""ca"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CA, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""ca"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CA, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""ca"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CA, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""ca"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CA, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""ca"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CA, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""ca"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(271): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CA, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""ca"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CA, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""ca"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CA, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""ca"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CA, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""ca"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CA, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""ca"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CA, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""ca"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CA, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""ca"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CA, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""ca"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(271): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CA, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""ca"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CA, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""ca"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CA, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""ca"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CA, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""ca"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CA, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""ca"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CA, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""ca"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CA, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""ca"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CA, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""ca"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(271): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CA, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""ca"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CA, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""ca"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CA, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""ca"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CA, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""ca"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CA, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""ca"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CA, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""ca"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CA, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""ca"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CA, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""ca"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(271): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CA, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""ca"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CA, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""ca"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CA, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""ca"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CA, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""ca"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CA, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""ca"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CA, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""ca"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CA, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""ca"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CA, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""ca"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(271): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CA, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""ca"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CA, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""ca"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CA, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""ca"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CA, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""ca"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CA, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""ca"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CA, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""ca"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CA, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""ca"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CA, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""ca"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(272): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CG, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cg"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CG, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cg"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CG, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cg"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CG, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cg"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CG, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cg"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CG, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cg"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CG, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cg"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CG, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cg"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                           ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(272): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CG, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cg"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CG, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cg"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CG, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cg"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CG, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cg"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CG, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cg"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CG, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cg"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CG, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cg"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CG, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cg"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(272): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CG, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cg"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CG, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cg"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CG, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cg"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CG, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cg"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CG, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cg"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CG, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cg"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CG, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cg"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CG, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cg"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(272): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CG, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cg"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CG, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cg"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CG, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cg"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CG, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cg"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CG, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cg"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CG, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cg"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CG, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cg"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CG, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cg"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(272): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CG, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cg"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CG, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cg"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CG, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cg"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CG, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cg"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CG, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cg"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CG, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cg"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CG, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cg"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CG, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cg"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(272): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CG, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cg"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CG, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cg"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CG, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cg"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CG, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cg"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CG, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cg"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CG, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cg"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CG, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cg"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CG, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cg"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(272): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CG, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cg"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CG, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cg"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CG, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cg"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CG, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cg"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CG, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cg"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CG, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cg"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CG, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cg"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CG, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cg"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(272): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CG, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cg"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CG, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cg"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CG, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cg"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CG, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cg"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CG, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cg"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CG, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cg"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CG, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cg"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CG, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cg"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(273): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CS, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cs"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CS, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cs"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CS, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cs"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CS, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cs"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CS, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cs"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CS, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cs"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CS, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cs"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CS, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cs"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                           ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(273): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CS, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cs"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CS, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cs"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CS, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cs"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CS, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cs"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CS, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cs"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CS, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cs"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CS, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cs"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CS, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cs"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(273): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CS, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cs"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CS, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cs"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CS, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cs"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CS, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cs"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CS, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cs"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CS, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cs"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CS, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cs"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CS, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cs"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(273): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CS, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cs"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CS, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cs"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CS, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cs"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CS, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cs"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CS, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cs"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CS, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cs"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CS, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cs"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CS, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cs"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(273): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CS, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cs"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CS, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cs"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CS, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cs"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CS, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cs"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CS, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cs"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CS, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cs"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CS, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cs"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CS, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cs"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(273): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CS, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cs"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CS, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cs"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CS, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cs"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CS, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cs"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CS, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cs"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CS, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cs"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CS, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cs"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CS, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cs"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(273): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CS, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cs"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CS, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cs"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CS, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cs"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CS, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cs"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CS, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cs"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CS, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cs"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CS, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cs"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CS, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cs"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(273): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CS, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cs"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CS, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cs"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CS, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cs"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CS, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cs"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CS, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cs"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CS, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cs"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CS, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cs"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CS, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cs"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(274): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CV, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cv"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CV, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cv"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CV, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cv"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CV, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cv"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CV, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cv"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CV, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cv"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CV, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cv"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CV, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cv"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                           ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(274): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CV, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cv"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CV, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cv"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CV, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cv"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CV, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cv"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CV, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cv"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CV, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cv"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CV, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cv"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CV, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cv"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(274): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CV, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cv"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CV, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cv"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CV, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cv"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CV, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cv"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CV, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cv"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CV, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cv"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CV, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cv"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CV, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cv"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(274): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CV, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cv"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CV, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cv"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CV, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cv"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CV, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cv"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CV, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cv"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CV, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cv"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CV, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cv"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CV, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cv"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(274): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CV, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cv"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CV, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cv"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CV, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cv"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CV, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cv"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CV, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cv"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CV, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cv"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CV, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cv"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CV, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cv"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(274): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CV, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cv"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CV, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cv"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CV, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cv"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CV, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cv"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CV, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cv"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CV, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cv"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CV, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cv"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CV, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cv"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(274): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CV, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cv"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CV, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cv"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CV, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cv"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CV, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cv"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CV, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cv"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CV, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cv"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CV, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cv"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CV, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cv"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(274): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_CV, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""cv"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_CV, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""cv"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_CV, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""cv"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_CV, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""cv"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_CV, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""cv"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_CV, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""cv"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_CV, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""cv"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_CV, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""cv"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(275): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_LDG, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""global.nc"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_LDG, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""global.nc"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_LDG, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""global.nc"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_LDG, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""global.nc"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_LDG, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""global.nc"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_LDG, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""global.nc"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_LDG, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""global.nc"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_LDG, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""global.nc"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                   ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(275): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_LDG, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""global.nc"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_LDG, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""global.nc"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_LDG, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""global.nc"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_LDG, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""global.nc"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_LDG, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""global.nc"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_LDG, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""global.nc"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_LDG, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""global.nc"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_LDG, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""global.nc"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(275): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_LDG, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""global.nc"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_LDG, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""global.nc"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_LDG, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""global.nc"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_LDG, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""global.nc"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_LDG, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""global.nc"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_LDG, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""global.nc"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_LDG, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""global.nc"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_LDG, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""global.nc"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(275): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_LDG, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""global.nc"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_LDG, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""global.nc"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_LDG, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""global.nc"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_LDG, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""global.nc"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_LDG, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""global.nc"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_LDG, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""global.nc"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_LDG, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""global.nc"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_LDG, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""global.nc"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(275): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_LDG, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""global.nc"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_LDG, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""global.nc"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_LDG, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""global.nc"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_LDG, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""global.nc"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_LDG, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""global.nc"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_LDG, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""global.nc"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_LDG, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""global.nc"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_LDG, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""global.nc"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(275): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_LDG, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""global.nc"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_LDG, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""global.nc"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_LDG, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""global.nc"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_LDG, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""global.nc"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_LDG, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""global.nc"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_LDG, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""global.nc"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_LDG, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""global.nc"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_LDG, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""global.nc"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(275): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_LDG, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""global.nc"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_LDG, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""global.nc"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_LDG, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""global.nc"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_LDG, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""global.nc"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_LDG, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""global.nc"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_LDG, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""global.nc"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_LDG, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""global.nc"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_LDG, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""global.nc"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_load.cuh(275): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline uint4 ThreadLoad<LOAD_LDG, uint4 const *>(uint4 const *ptr) { uint4 retval; asm volatile ("ld.""global.nc"".v4.u32 {%0, %1, %2, %3}, [%4];" : "=r"(retval.x), "=r"(retval.y), "=r"(retval.z), "=r"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ulonglong2 ThreadLoad<LOAD_LDG, ulonglong2 const *>(ulonglong2 const *ptr) { ulonglong2 retval; asm volatile ("ld.""global.nc"".v2.u64 {%0, %1}, [%2];" : "=l"(retval.x), "=l"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline ushort4 ThreadLoad<LOAD_LDG, ushort4 const *>(ushort4 const *ptr) { ushort4 retval; asm volatile ("ld.""global.nc"".v4.u16 {%0, %1, %2, %3}, [%4];" : "=h"(retval.x), "=h"(retval.y), "=h"(retval.z), "=h"(retval.w) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline uint2 ThreadLoad<LOAD_LDG, uint2 const *>(uint2 const *ptr) { uint2 retval; asm volatile ("ld.""global.nc"".v2.u32 {%0, %1}, [%2];" : "=r"(retval.x), "=r"(retval.y) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned long long ThreadLoad<LOAD_LDG, unsigned long long const *>(unsigned long long const *ptr) { unsigned long long retval; asm volatile ("ld.""global.nc"".u64 %0, [%1];" : "=l"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned int ThreadLoad<LOAD_LDG, unsigned int const *>(unsigned int const *ptr) { unsigned int retval; asm volatile ("ld.""global.nc"".u32 %0, [%1];" : "=r"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned short ThreadLoad<LOAD_LDG, unsigned short const *>(unsigned short const *ptr) { unsigned short retval; asm volatile ("ld.""global.nc"".u16 %0, [%1];" : "=h"(retval) : "r"(ptr)); return retval; } template<> __declspec(__device__) __forceinline unsigned char ThreadLoad<LOAD_LDG, unsigned char const *>(unsigned char const *ptr) { unsigned short retval; asm volatile ( "{" "   .reg .u8 datum;" "    ld.""global.nc"".u8 datum, [%1];" "    cvt.u16.u8 %0, datum;" "}" : "=h"(retval) : "r"(ptr)); return (unsigned char) retval; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_store.cuh(260): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""wb"".v4.u32 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""wb"".v2.u64 [%0], {%1, %2};" : : "r"(ptr), "l"(val.x), "l"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""wb"".v4.u16 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""wb"".v2.u32 [%0], {%1, %2};" : : "r"(ptr), "r"(val.x), "r"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""wb"".u64 [%0], %1;" : : "r"(ptr), "l"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""wb"".u32 [%0], %1;" : : "r"(ptr), "r"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""wb"".u16 [%0], %1;" : : "r"(ptr), "h"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""wb"".u8 [%0], datum;" "}" : : "r"(ptr), "h"((unsigned short) val)); }
                                                                                                                                                                                    ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_store.cuh(260): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""wb"".v4.u32 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""wb"".v2.u64 [%0], {%1, %2};" : : "r"(ptr), "l"(val.x), "l"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""wb"".v4.u16 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""wb"".v2.u32 [%0], {%1, %2};" : : "r"(ptr), "r"(val.x), "r"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""wb"".u64 [%0], %1;" : : "r"(ptr), "l"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""wb"".u32 [%0], %1;" : : "r"(ptr), "r"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""wb"".u16 [%0], %1;" : : "r"(ptr), "h"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""wb"".u8 [%0], datum;" "}" : : "r"(ptr), "h"((unsigned short) val)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_store.cuh(260): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""wb"".v4.u32 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""wb"".v2.u64 [%0], {%1, %2};" : : "r"(ptr), "l"(val.x), "l"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""wb"".v4.u16 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""wb"".v2.u32 [%0], {%1, %2};" : : "r"(ptr), "r"(val.x), "r"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""wb"".u64 [%0], %1;" : : "r"(ptr), "l"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""wb"".u32 [%0], %1;" : : "r"(ptr), "r"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""wb"".u16 [%0], %1;" : : "r"(ptr), "h"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""wb"".u8 [%0], datum;" "}" : : "r"(ptr), "h"((unsigned short) val)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_store.cuh(260): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""wb"".v4.u32 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""wb"".v2.u64 [%0], {%1, %2};" : : "r"(ptr), "l"(val.x), "l"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""wb"".v4.u16 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""wb"".v2.u32 [%0], {%1, %2};" : : "r"(ptr), "r"(val.x), "r"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""wb"".u64 [%0], %1;" : : "r"(ptr), "l"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""wb"".u32 [%0], %1;" : : "r"(ptr), "r"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""wb"".u16 [%0], %1;" : : "r"(ptr), "h"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""wb"".u8 [%0], datum;" "}" : : "r"(ptr), "h"((unsigned short) val)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_store.cuh(260): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""wb"".v4.u32 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""wb"".v2.u64 [%0], {%1, %2};" : : "r"(ptr), "l"(val.x), "l"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""wb"".v4.u16 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""wb"".v2.u32 [%0], {%1, %2};" : : "r"(ptr), "r"(val.x), "r"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""wb"".u64 [%0], %1;" : : "r"(ptr), "l"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""wb"".u32 [%0], %1;" : : "r"(ptr), "r"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""wb"".u16 [%0], %1;" : : "r"(ptr), "h"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""wb"".u8 [%0], datum;" "}" : : "r"(ptr), "h"((unsigned short) val)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_store.cuh(260): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""wb"".v4.u32 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""wb"".v2.u64 [%0], {%1, %2};" : : "r"(ptr), "l"(val.x), "l"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""wb"".v4.u16 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""wb"".v2.u32 [%0], {%1, %2};" : : "r"(ptr), "r"(val.x), "r"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""wb"".u64 [%0], %1;" : : "r"(ptr), "l"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""wb"".u32 [%0], %1;" : : "r"(ptr), "r"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""wb"".u16 [%0], %1;" : : "r"(ptr), "h"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""wb"".u8 [%0], datum;" "}" : : "r"(ptr), "h"((unsigned short) val)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_store.cuh(260): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""wb"".v4.u32 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""wb"".v2.u64 [%0], {%1, %2};" : : "r"(ptr), "l"(val.x), "l"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""wb"".v4.u16 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""wb"".v2.u32 [%0], {%1, %2};" : : "r"(ptr), "r"(val.x), "r"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""wb"".u64 [%0], %1;" : : "r"(ptr), "l"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""wb"".u32 [%0], %1;" : : "r"(ptr), "r"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""wb"".u16 [%0], %1;" : : "r"(ptr), "h"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""wb"".u8 [%0], datum;" "}" : : "r"(ptr), "h"((unsigned short) val)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_store.cuh(260): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""wb"".v4.u32 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""wb"".v2.u64 [%0], {%1, %2};" : : "r"(ptr), "l"(val.x), "l"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""wb"".v4.u16 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""wb"".v2.u32 [%0], {%1, %2};" : : "r"(ptr), "r"(val.x), "r"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""wb"".u64 [%0], %1;" : : "r"(ptr), "l"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""wb"".u32 [%0], %1;" : : "r"(ptr), "r"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""wb"".u16 [%0], %1;" : : "r"(ptr), "h"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_WB, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""wb"".u8 [%0], datum;" "}" : : "r"(ptr), "h"((unsigned short) val)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_store.cuh(261): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""cg"".v4.u32 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""cg"".v2.u64 [%0], {%1, %2};" : : "r"(ptr), "l"(val.x), "l"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""cg"".v4.u16 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""cg"".v2.u32 [%0], {%1, %2};" : : "r"(ptr), "r"(val.x), "r"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""cg"".u64 [%0], %1;" : : "r"(ptr), "l"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""cg"".u32 [%0], %1;" : : "r"(ptr), "r"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""cg"".u16 [%0], %1;" : : "r"(ptr), "h"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""cg"".u8 [%0], datum;" "}" : : "r"(ptr), "h"((unsigned short) val)); }
                                                                                                                                                                                    ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_store.cuh(261): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""cg"".v4.u32 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""cg"".v2.u64 [%0], {%1, %2};" : : "r"(ptr), "l"(val.x), "l"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""cg"".v4.u16 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""cg"".v2.u32 [%0], {%1, %2};" : : "r"(ptr), "r"(val.x), "r"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""cg"".u64 [%0], %1;" : : "r"(ptr), "l"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""cg"".u32 [%0], %1;" : : "r"(ptr), "r"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""cg"".u16 [%0], %1;" : : "r"(ptr), "h"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""cg"".u8 [%0], datum;" "}" : : "r"(ptr), "h"((unsigned short) val)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_store.cuh(261): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""cg"".v4.u32 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""cg"".v2.u64 [%0], {%1, %2};" : : "r"(ptr), "l"(val.x), "l"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""cg"".v4.u16 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""cg"".v2.u32 [%0], {%1, %2};" : : "r"(ptr), "r"(val.x), "r"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""cg"".u64 [%0], %1;" : : "r"(ptr), "l"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""cg"".u32 [%0], %1;" : : "r"(ptr), "r"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""cg"".u16 [%0], %1;" : : "r"(ptr), "h"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""cg"".u8 [%0], datum;" "}" : : "r"(ptr), "h"((unsigned short) val)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_store.cuh(261): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""cg"".v4.u32 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""cg"".v2.u64 [%0], {%1, %2};" : : "r"(ptr), "l"(val.x), "l"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""cg"".v4.u16 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""cg"".v2.u32 [%0], {%1, %2};" : : "r"(ptr), "r"(val.x), "r"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""cg"".u64 [%0], %1;" : : "r"(ptr), "l"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""cg"".u32 [%0], %1;" : : "r"(ptr), "r"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""cg"".u16 [%0], %1;" : : "r"(ptr), "h"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""cg"".u8 [%0], datum;" "}" : : "r"(ptr), "h"((unsigned short) val)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_store.cuh(261): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""cg"".v4.u32 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""cg"".v2.u64 [%0], {%1, %2};" : : "r"(ptr), "l"(val.x), "l"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""cg"".v4.u16 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""cg"".v2.u32 [%0], {%1, %2};" : : "r"(ptr), "r"(val.x), "r"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""cg"".u64 [%0], %1;" : : "r"(ptr), "l"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""cg"".u32 [%0], %1;" : : "r"(ptr), "r"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""cg"".u16 [%0], %1;" : : "r"(ptr), "h"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""cg"".u8 [%0], datum;" "}" : : "r"(ptr), "h"((unsigned short) val)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_store.cuh(261): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""cg"".v4.u32 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""cg"".v2.u64 [%0], {%1, %2};" : : "r"(ptr), "l"(val.x), "l"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""cg"".v4.u16 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""cg"".v2.u32 [%0], {%1, %2};" : : "r"(ptr), "r"(val.x), "r"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""cg"".u64 [%0], %1;" : : "r"(ptr), "l"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""cg"".u32 [%0], %1;" : : "r"(ptr), "r"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""cg"".u16 [%0], %1;" : : "r"(ptr), "h"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""cg"".u8 [%0], datum;" "}" : : "r"(ptr), "h"((unsigned short) val)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_store.cuh(261): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""cg"".v4.u32 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""cg"".v2.u64 [%0], {%1, %2};" : : "r"(ptr), "l"(val.x), "l"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""cg"".v4.u16 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""cg"".v2.u32 [%0], {%1, %2};" : : "r"(ptr), "r"(val.x), "r"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""cg"".u64 [%0], %1;" : : "r"(ptr), "l"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""cg"".u32 [%0], %1;" : : "r"(ptr), "r"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""cg"".u16 [%0], %1;" : : "r"(ptr), "h"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""cg"".u8 [%0], datum;" "}" : : "r"(ptr), "h"((unsigned short) val)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_store.cuh(261): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""cg"".v4.u32 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""cg"".v2.u64 [%0], {%1, %2};" : : "r"(ptr), "l"(val.x), "l"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""cg"".v4.u16 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""cg"".v2.u32 [%0], {%1, %2};" : : "r"(ptr), "r"(val.x), "r"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""cg"".u64 [%0], %1;" : : "r"(ptr), "l"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""cg"".u32 [%0], %1;" : : "r"(ptr), "r"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""cg"".u16 [%0], %1;" : : "r"(ptr), "h"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CG, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""cg"".u8 [%0], datum;" "}" : : "r"(ptr), "h"((unsigned short) val)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_store.cuh(262): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CS, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""cs"".v4.u32 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CS, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""cs"".v2.u64 [%0], {%1, %2};" : : "r"(ptr), "l"(val.x), "l"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CS, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""cs"".v4.u16 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CS, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""cs"".v2.u32 [%0], {%1, %2};" : : "r"(ptr), "r"(val.x), "r"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CS, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""cs"".u64 [%0], %1;" : : "r"(ptr), "l"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CS, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""cs"".u32 [%0], %1;" : : "r"(ptr), "r"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CS, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""cs"".u16 [%0], %1;" : : "r"(ptr), "h"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CS, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""cs"".u8 [%0], datum;" "}" : : "r"(ptr), "h"((unsigned short) val)); }
                                                                                                                                                                                    ^
  
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include\cub\iterator\../thread/thread_store.cuh(262): error : asm operand type size(8) does not match type/size implied by constraint 'r'
    template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CS, uint4*, uint4>(uint4* ptr, uint4 val) { asm volatile ("st.""cs"".v4.u32 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "r"(val.x), "r"(val.y), "r"(val.z), "r"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CS, ulonglong2*, ulonglong2>(ulonglong2* ptr, ulonglong2 val) { asm volatile ("st.""cs"".v2.u64 [%0], {%1, %2};" : : "r"(ptr), "l"(val.x), "l"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CS, ushort4*, ushort4>(ushort4* ptr, ushort4 val) { asm volatile ("st.""cs"".v4.u16 [%0], {%1, %2, %3, %4};" : : "r"(ptr), "h"(val.x), "h"(val.y), "h"(val.z), "h"(val.w)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CS, uint2*, uint2>(uint2* ptr, uint2 val) { asm volatile ("st.""cs"".v2.u32 [%0], {%1, %2};" : : "r"(ptr), "r"(val.x), "r"(val.y)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CS, unsigned long long*, unsigned long long>(unsigned long long* ptr, unsigned long long val) { asm volatile ("st.""cs"".u64 [%0], %1;" : : "r"(ptr), "l"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CS, unsigned int*, unsigned int>(unsigned int* ptr, unsigned int val) { asm volatile ("st.""cs"".u32 [%0], %1;" : : "r"(ptr), "r"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CS, unsigned short*, unsigned short>(unsigned short* ptr, unsigned short val) { asm volatile ("st.""cs"".u16 [%0], %1;" : : "r"(ptr), "h"(val)); } template<> __declspec(__device__) __forceinline void ThreadStore<STORE_CS, unsigned char*, unsigned char>(unsigned char* ptr, unsigned char val) { asm volatile ( "{" "   .reg .u8 datum;" "   cvt.u8.u16 datum, %1;" "   st.""cs"".u8 [%0], datum;" "}" : : "r"(ptr), "h"((unsigned short) val)); }
                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
  
  Error limit reached.
  100 errors detected in the compilation of "C:/Users/Liang Nie/Documents/GitHub/VisualStudioRepository/Project1/Project1/main.cu".
  Compilation terminated.
  main.cu
C:\Program Files\Microsoft Visual Studio\2022\Community\MSBuild\Microsoft\VC\v170\BuildCustomizations\CUDA 12.1.targets(799,9): error MSB3721: The command ""C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\bin\nvcc.exe" -gencode=arch=compute_86,code=\"sm_86,compute_86\" --use-local-env -ccbin "C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.36.32532\bin\HostX86\x86" -x cu   -I"C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include" -I"C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include" -I"C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.1\include"  -G   --keep-dir Debug  -maxrregcount=0   --machine 64 --compile -cudart static  -g  -DWIN32 -D_DEBUG -D_CONSOLE -D_UNICODE -DUNICODE -Xcompiler "/EHsc /W3 /nologo /Od /FS /Zi /RTC1 /MDd " -Xcompiler "/FdDebug\vc143.pdb" -o "C:\Users\Liang Nie\Documents\GitHub\VisualStudioRepository\Project1\Project1\Debug\main.cu.obj" "C:\Users\Liang Nie\Documents\GitHub\VisualStudioRepository\Project1\Project1\main.cu"" exited with code 4.
